// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: utils/AIAssistant.pipeMsg.proto
// Protobuf C++ Version: 5.29.0-dev

#ifndef utils_2fAIAssistant_2epipeMsg_2eproto_2epb_2eh
#define utils_2fAIAssistant_2epipeMsg_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_utils_2fAIAssistant_2epipeMsg_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_utils_2fAIAssistant_2epipeMsg_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_utils_2fAIAssistant_2epipeMsg_2eproto;
namespace AIAssistant {
class command;
struct commandDefaultTypeInternal;
extern commandDefaultTypeInternal _command_default_instance_;
class commandResponse;
struct commandResponseDefaultTypeInternal;
extern commandResponseDefaultTypeInternal _commandResponse_default_instance_;
class command_ParamsEntry_DoNotUse;
struct command_ParamsEntry_DoNotUseDefaultTypeInternal;
extern command_ParamsEntry_DoNotUseDefaultTypeInternal _command_ParamsEntry_DoNotUse_default_instance_;
class init;
struct initDefaultTypeInternal;
extern initDefaultTypeInternal _init_default_instance_;
class initResponse;
struct initResponseDefaultTypeInternal;
extern initResponseDefaultTypeInternal _initResponse_default_instance_;
class statusRepost;
struct statusRepostDefaultTypeInternal;
extern statusRepostDefaultTypeInternal _statusRepost_default_instance_;
class userContext;
struct userContextDefaultTypeInternal;
extern userContextDefaultTypeInternal _userContext_default_instance_;
class userContext_ContextEntry_DoNotUse;
struct userContext_ContextEntry_DoNotUseDefaultTypeInternal;
extern userContext_ContextEntry_DoNotUseDefaultTypeInternal _userContext_ContextEntry_DoNotUse_default_instance_;
}  // namespace AIAssistant
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace AIAssistant {

// ===================================================================


// -------------------------------------------------------------------

class userContext_ContextEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  userContext_ContextEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR userContext_ContextEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit userContext_ContextEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const userContext_ContextEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const userContext_ContextEntry_DoNotUse*>(
        &_userContext_ContextEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_utils_2fAIAssistant_2epipeMsg_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      53, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class statusRepost final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AIAssistant.statusRepost) */ {
 public:
  inline statusRepost() : statusRepost(nullptr) {}
  ~statusRepost() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(statusRepost* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(statusRepost));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR statusRepost(
      ::google::protobuf::internal::ConstantInitialized);

  inline statusRepost(const statusRepost& from) : statusRepost(nullptr, from) {}
  inline statusRepost(statusRepost&& from) noexcept
      : statusRepost(nullptr, std::move(from)) {}
  inline statusRepost& operator=(const statusRepost& from) {
    CopyFrom(from);
    return *this;
  }
  inline statusRepost& operator=(statusRepost&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const statusRepost& default_instance() {
    return *internal_default_instance();
  }
  static inline const statusRepost* internal_default_instance() {
    return reinterpret_cast<const statusRepost*>(
        &_statusRepost_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(statusRepost& a, statusRepost& b) { a.Swap(&b); }
  inline void Swap(statusRepost* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(statusRepost* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  statusRepost* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<statusRepost>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const statusRepost& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const statusRepost& from) { statusRepost::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(statusRepost* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "AIAssistant.statusRepost"; }

 protected:
  explicit statusRepost(::google::protobuf::Arena* arena);
  statusRepost(::google::protobuf::Arena* arena, const statusRepost& from);
  statusRepost(::google::protobuf::Arena* arena, statusRepost&& from) noexcept
      : statusRepost(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResponseMsgFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // required string responseMsg = 2;
  bool has_responsemsg() const;
  void clear_responsemsg() ;
  const std::string& responsemsg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_responsemsg(Arg_&& arg, Args_... args);
  std::string* mutable_responsemsg();
  PROTOBUF_NODISCARD std::string* release_responsemsg();
  void set_allocated_responsemsg(std::string* value);

  private:
  const std::string& _internal_responsemsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_responsemsg(
      const std::string& value);
  std::string* _internal_mutable_responsemsg();

  public:
  // required int32 status = 1;
  bool has_status() const;
  void clear_status() ;
  ::int32_t status() const;
  void set_status(::int32_t value);

  private:
  ::int32_t _internal_status() const;
  void _internal_set_status(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:AIAssistant.statusRepost)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      44, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_statusRepost_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const statusRepost& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr responsemsg_;
    ::int32_t status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_utils_2fAIAssistant_2epipeMsg_2eproto;
};
// -------------------------------------------------------------------

class initResponse final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AIAssistant.initResponse) */ {
 public:
  inline initResponse() : initResponse(nullptr) {}
  ~initResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(initResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(initResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR initResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline initResponse(const initResponse& from) : initResponse(nullptr, from) {}
  inline initResponse(initResponse&& from) noexcept
      : initResponse(nullptr, std::move(from)) {}
  inline initResponse& operator=(const initResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline initResponse& operator=(initResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const initResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const initResponse* internal_default_instance() {
    return reinterpret_cast<const initResponse*>(
        &_initResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(initResponse& a, initResponse& b) { a.Swap(&b); }
  inline void Swap(initResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(initResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  initResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<initResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const initResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const initResponse& from) { initResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(initResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "AIAssistant.initResponse"; }

 protected:
  explicit initResponse(::google::protobuf::Arena* arena);
  initResponse(::google::protobuf::Arena* arena, const initResponse& from);
  initResponse(::google::protobuf::Arena* arena, initResponse&& from) noexcept
      : initResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResponseMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // required string responseMsg = 2;
  bool has_responsemsg() const;
  void clear_responsemsg() ;
  const std::string& responsemsg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_responsemsg(Arg_&& arg, Args_... args);
  std::string* mutable_responsemsg();
  PROTOBUF_NODISCARD std::string* release_responsemsg();
  void set_allocated_responsemsg(std::string* value);

  private:
  const std::string& _internal_responsemsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_responsemsg(
      const std::string& value);
  std::string* _internal_mutable_responsemsg();

  public:
  // required bool success = 1;
  bool has_success() const;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:AIAssistant.initResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      44, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_initResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const initResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr responsemsg_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_utils_2fAIAssistant_2epipeMsg_2eproto;
};
// -------------------------------------------------------------------

class init final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AIAssistant.init) */ {
 public:
  inline init() : init(nullptr) {}
  ~init() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(init* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(init));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR init(
      ::google::protobuf::internal::ConstantInitialized);

  inline init(const init& from) : init(nullptr, from) {}
  inline init(init&& from) noexcept
      : init(nullptr, std::move(from)) {}
  inline init& operator=(const init& from) {
    CopyFrom(from);
    return *this;
  }
  inline init& operator=(init&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const init& default_instance() {
    return *internal_default_instance();
  }
  static inline const init* internal_default_instance() {
    return reinterpret_cast<const init*>(
        &_init_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(init& a, init& b) { a.Swap(&b); }
  inline void Swap(init* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(init* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  init* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<init>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const init& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const init& from) { init::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(init* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "AIAssistant.init"; }

 protected:
  explicit init(::google::protobuf::Arena* arena);
  init(::google::protobuf::Arena* arena, const init& from);
  init(::google::protobuf::Arena* arena, init&& from) noexcept
      : init(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSoftwareNameFieldNumber = 1,
    kSoftwareVersionFieldNumber = 2,
    kRobotIDFieldNumber = 3,
    kRobotSecretKeyFieldNumber = 4,
    kSystemVersionFieldNumber = 5,
    kSoftWareXPosFieldNumber = 6,
    kSoftWareYPosFieldNumber = 7,
    kSoftWareWidthFieldNumber = 8,
    kSoftWareHeightFieldNumber = 9,
  };
  // required string softwareName = 1;
  bool has_softwarename() const;
  void clear_softwarename() ;
  const std::string& softwarename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_softwarename(Arg_&& arg, Args_... args);
  std::string* mutable_softwarename();
  PROTOBUF_NODISCARD std::string* release_softwarename();
  void set_allocated_softwarename(std::string* value);

  private:
  const std::string& _internal_softwarename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_softwarename(
      const std::string& value);
  std::string* _internal_mutable_softwarename();

  public:
  // required string softwareVersion = 2;
  bool has_softwareversion() const;
  void clear_softwareversion() ;
  const std::string& softwareversion() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_softwareversion(Arg_&& arg, Args_... args);
  std::string* mutable_softwareversion();
  PROTOBUF_NODISCARD std::string* release_softwareversion();
  void set_allocated_softwareversion(std::string* value);

  private:
  const std::string& _internal_softwareversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_softwareversion(
      const std::string& value);
  std::string* _internal_mutable_softwareversion();

  public:
  // required string robotID = 3;
  bool has_robotid() const;
  void clear_robotid() ;
  const std::string& robotid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_robotid(Arg_&& arg, Args_... args);
  std::string* mutable_robotid();
  PROTOBUF_NODISCARD std::string* release_robotid();
  void set_allocated_robotid(std::string* value);

  private:
  const std::string& _internal_robotid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robotid(
      const std::string& value);
  std::string* _internal_mutable_robotid();

  public:
  // required string robotSecretKey = 4;
  bool has_robotsecretkey() const;
  void clear_robotsecretkey() ;
  const std::string& robotsecretkey() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_robotsecretkey(Arg_&& arg, Args_... args);
  std::string* mutable_robotsecretkey();
  PROTOBUF_NODISCARD std::string* release_robotsecretkey();
  void set_allocated_robotsecretkey(std::string* value);

  private:
  const std::string& _internal_robotsecretkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robotsecretkey(
      const std::string& value);
  std::string* _internal_mutable_robotsecretkey();

  public:
  // required string systemVersion = 5;
  bool has_systemversion() const;
  void clear_systemversion() ;
  const std::string& systemversion() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_systemversion(Arg_&& arg, Args_... args);
  std::string* mutable_systemversion();
  PROTOBUF_NODISCARD std::string* release_systemversion();
  void set_allocated_systemversion(std::string* value);

  private:
  const std::string& _internal_systemversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_systemversion(
      const std::string& value);
  std::string* _internal_mutable_systemversion();

  public:
  // required int32 softWareXPos = 6;
  bool has_softwarexpos() const;
  void clear_softwarexpos() ;
  ::int32_t softwarexpos() const;
  void set_softwarexpos(::int32_t value);

  private:
  ::int32_t _internal_softwarexpos() const;
  void _internal_set_softwarexpos(::int32_t value);

  public:
  // required int32 softWareYPos = 7;
  bool has_softwareypos() const;
  void clear_softwareypos() ;
  ::int32_t softwareypos() const;
  void set_softwareypos(::int32_t value);

  private:
  ::int32_t _internal_softwareypos() const;
  void _internal_set_softwareypos(::int32_t value);

  public:
  // required int32 softWareWidth = 8;
  bool has_softwarewidth() const;
  void clear_softwarewidth() ;
  ::int32_t softwarewidth() const;
  void set_softwarewidth(::int32_t value);

  private:
  ::int32_t _internal_softwarewidth() const;
  void _internal_set_softwarewidth(::int32_t value);

  public:
  // required int32 softWareHeight = 9;
  bool has_softwareheight() const;
  void clear_softwareheight() ;
  ::int32_t softwareheight() const;
  void set_softwareheight(::int32_t value);

  private:
  ::int32_t _internal_softwareheight() const;
  void _internal_set_softwareheight(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:AIAssistant.init)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 0,
      94, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_init_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const init& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr softwarename_;
    ::google::protobuf::internal::ArenaStringPtr softwareversion_;
    ::google::protobuf::internal::ArenaStringPtr robotid_;
    ::google::protobuf::internal::ArenaStringPtr robotsecretkey_;
    ::google::protobuf::internal::ArenaStringPtr systemversion_;
    ::int32_t softwarexpos_;
    ::int32_t softwareypos_;
    ::int32_t softwarewidth_;
    ::int32_t softwareheight_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_utils_2fAIAssistant_2epipeMsg_2eproto;
};
// -------------------------------------------------------------------

class commandResponse final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AIAssistant.commandResponse) */ {
 public:
  inline commandResponse() : commandResponse(nullptr) {}
  ~commandResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(commandResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(commandResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR commandResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline commandResponse(const commandResponse& from) : commandResponse(nullptr, from) {}
  inline commandResponse(commandResponse&& from) noexcept
      : commandResponse(nullptr, std::move(from)) {}
  inline commandResponse& operator=(const commandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline commandResponse& operator=(commandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const commandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const commandResponse* internal_default_instance() {
    return reinterpret_cast<const commandResponse*>(
        &_commandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(commandResponse& a, commandResponse& b) { a.Swap(&b); }
  inline void Swap(commandResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(commandResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  commandResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<commandResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const commandResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const commandResponse& from) { commandResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(commandResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "AIAssistant.commandResponse"; }

 protected:
  explicit commandResponse(::google::protobuf::Arena* arena);
  commandResponse(::google::protobuf::Arena* arena, const commandResponse& from);
  commandResponse(::google::protobuf::Arena* arena, commandResponse&& from) noexcept
      : commandResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResponseMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // required string responseMsg = 2;
  bool has_responsemsg() const;
  void clear_responsemsg() ;
  const std::string& responsemsg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_responsemsg(Arg_&& arg, Args_... args);
  std::string* mutable_responsemsg();
  PROTOBUF_NODISCARD std::string* release_responsemsg();
  void set_allocated_responsemsg(std::string* value);

  private:
  const std::string& _internal_responsemsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_responsemsg(
      const std::string& value);
  std::string* _internal_mutable_responsemsg();

  public:
  // required bool success = 1;
  bool has_success() const;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:AIAssistant.commandResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      47, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_commandResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const commandResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr responsemsg_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_utils_2fAIAssistant_2epipeMsg_2eproto;
};
// -------------------------------------------------------------------

class command_ParamsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  command_ParamsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR command_ParamsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit command_ParamsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const command_ParamsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const command_ParamsEntry_DoNotUse*>(
        &_command_ParamsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_utils_2fAIAssistant_2epipeMsg_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      48, 2>
      _table_;

  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::Message::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class userContext final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AIAssistant.userContext) */ {
 public:
  inline userContext() : userContext(nullptr) {}
  ~userContext() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(userContext* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(userContext));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR userContext(
      ::google::protobuf::internal::ConstantInitialized);

  inline userContext(const userContext& from) : userContext(nullptr, from) {}
  inline userContext(userContext&& from) noexcept
      : userContext(nullptr, std::move(from)) {}
  inline userContext& operator=(const userContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline userContext& operator=(userContext&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const userContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const userContext* internal_default_instance() {
    return reinterpret_cast<const userContext*>(
        &_userContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(userContext& a, userContext& b) { a.Swap(&b); }
  inline void Swap(userContext* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(userContext* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  userContext* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<userContext>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const userContext& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const userContext& from) { userContext::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(userContext* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "AIAssistant.userContext"; }

 protected:
  explicit userContext(::google::protobuf::Arena* arena);
  userContext(::google::protobuf::Arena* arena, const userContext& from);
  userContext(::google::protobuf::Arena* arena, userContext&& from) noexcept
      : userContext(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kContextFieldNumber = 1,
  };
  // map<string, string> context = 1;
  int context_size() const;
  private:
  int _internal_context_size() const;

  public:
  void clear_context() ;
  const ::google::protobuf::Map<std::string, std::string>& context() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_context();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_context() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_context();

  public:
  // @@protoc_insertion_point(class_scope:AIAssistant.userContext)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      39, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_userContext_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const userContext& from_msg);
    ::google::protobuf::internal::MapField<userContext_ContextEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        context_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_utils_2fAIAssistant_2epipeMsg_2eproto;
};
// -------------------------------------------------------------------

class command final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:AIAssistant.command) */ {
 public:
  inline command() : command(nullptr) {}
  ~command() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(command* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(command));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR command(
      ::google::protobuf::internal::ConstantInitialized);

  inline command(const command& from) : command(nullptr, from) {}
  inline command(command&& from) noexcept
      : command(nullptr, std::move(from)) {}
  inline command& operator=(const command& from) {
    CopyFrom(from);
    return *this;
  }
  inline command& operator=(command&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const command& default_instance() {
    return *internal_default_instance();
  }
  static inline const command* internal_default_instance() {
    return reinterpret_cast<const command*>(
        &_command_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(command& a, command& b) { a.Swap(&b); }
  inline void Swap(command* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(command* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  command* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<command>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const command& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const command& from) { command::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(command* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "AIAssistant.command"; }

 protected:
  explicit command(::google::protobuf::Arena* arena);
  command(::google::protobuf::Arena* arena, const command& from);
  command(::google::protobuf::Arena* arena, command&& from) noexcept
      : command(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParamsFieldNumber = 2,
    kCommandMsgFieldNumber = 1,
  };
  // map<string, string> params = 2;
  int params_size() const;
  private:
  int _internal_params_size() const;

  public:
  void clear_params() ;
  const ::google::protobuf::Map<std::string, std::string>& params() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_params();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_params() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_params();

  public:
  // required string commandMsg = 1;
  bool has_commandmsg() const;
  void clear_commandmsg() ;
  const std::string& commandmsg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_commandmsg(Arg_&& arg, Args_... args);
  std::string* mutable_commandmsg();
  PROTOBUF_NODISCARD std::string* release_commandmsg();
  void set_allocated_commandmsg(std::string* value);

  private:
  const std::string& _internal_commandmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commandmsg(
      const std::string& value);
  std::string* _internal_mutable_commandmsg();

  public:
  // @@protoc_insertion_point(class_scope:AIAssistant.command)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      44, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_command_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const command& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<command_ParamsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        params_;
    ::google::protobuf::internal::ArenaStringPtr commandmsg_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_utils_2fAIAssistant_2epipeMsg_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// init

// required string softwareName = 1;
inline bool init::has_softwarename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void init::clear_softwarename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.softwarename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& init::softwarename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AIAssistant.init.softwareName)
  return _internal_softwarename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void init::set_softwarename(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.softwarename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:AIAssistant.init.softwareName)
}
inline std::string* init::mutable_softwarename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_softwarename();
  // @@protoc_insertion_point(field_mutable:AIAssistant.init.softwareName)
  return _s;
}
inline const std::string& init::_internal_softwarename() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.softwarename_.Get();
}
inline void init::_internal_set_softwarename(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.softwarename_.Set(value, GetArena());
}
inline std::string* init::_internal_mutable_softwarename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.softwarename_.Mutable( GetArena());
}
inline std::string* init::release_softwarename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AIAssistant.init.softwareName)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.softwarename_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.softwarename_.Set("", GetArena());
  }
  return released;
}
inline void init::set_allocated_softwarename(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.softwarename_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.softwarename_.IsDefault()) {
    _impl_.softwarename_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:AIAssistant.init.softwareName)
}

// required string softwareVersion = 2;
inline bool init::has_softwareversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void init::clear_softwareversion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.softwareversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& init::softwareversion() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AIAssistant.init.softwareVersion)
  return _internal_softwareversion();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void init::set_softwareversion(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.softwareversion_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:AIAssistant.init.softwareVersion)
}
inline std::string* init::mutable_softwareversion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_softwareversion();
  // @@protoc_insertion_point(field_mutable:AIAssistant.init.softwareVersion)
  return _s;
}
inline const std::string& init::_internal_softwareversion() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.softwareversion_.Get();
}
inline void init::_internal_set_softwareversion(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.softwareversion_.Set(value, GetArena());
}
inline std::string* init::_internal_mutable_softwareversion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.softwareversion_.Mutable( GetArena());
}
inline std::string* init::release_softwareversion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AIAssistant.init.softwareVersion)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.softwareversion_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.softwareversion_.Set("", GetArena());
  }
  return released;
}
inline void init::set_allocated_softwareversion(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.softwareversion_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.softwareversion_.IsDefault()) {
    _impl_.softwareversion_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:AIAssistant.init.softwareVersion)
}

// required string robotID = 3;
inline bool init::has_robotid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void init::clear_robotid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.robotid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& init::robotid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AIAssistant.init.robotID)
  return _internal_robotid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void init::set_robotid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.robotid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:AIAssistant.init.robotID)
}
inline std::string* init::mutable_robotid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_robotid();
  // @@protoc_insertion_point(field_mutable:AIAssistant.init.robotID)
  return _s;
}
inline const std::string& init::_internal_robotid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.robotid_.Get();
}
inline void init::_internal_set_robotid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.robotid_.Set(value, GetArena());
}
inline std::string* init::_internal_mutable_robotid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.robotid_.Mutable( GetArena());
}
inline std::string* init::release_robotid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AIAssistant.init.robotID)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.robotid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.robotid_.Set("", GetArena());
  }
  return released;
}
inline void init::set_allocated_robotid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.robotid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.robotid_.IsDefault()) {
    _impl_.robotid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:AIAssistant.init.robotID)
}

// required string robotSecretKey = 4;
inline bool init::has_robotsecretkey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void init::clear_robotsecretkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.robotsecretkey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& init::robotsecretkey() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AIAssistant.init.robotSecretKey)
  return _internal_robotsecretkey();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void init::set_robotsecretkey(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.robotsecretkey_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:AIAssistant.init.robotSecretKey)
}
inline std::string* init::mutable_robotsecretkey() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_robotsecretkey();
  // @@protoc_insertion_point(field_mutable:AIAssistant.init.robotSecretKey)
  return _s;
}
inline const std::string& init::_internal_robotsecretkey() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.robotsecretkey_.Get();
}
inline void init::_internal_set_robotsecretkey(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.robotsecretkey_.Set(value, GetArena());
}
inline std::string* init::_internal_mutable_robotsecretkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.robotsecretkey_.Mutable( GetArena());
}
inline std::string* init::release_robotsecretkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AIAssistant.init.robotSecretKey)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.robotsecretkey_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.robotsecretkey_.Set("", GetArena());
  }
  return released;
}
inline void init::set_allocated_robotsecretkey(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.robotsecretkey_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.robotsecretkey_.IsDefault()) {
    _impl_.robotsecretkey_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:AIAssistant.init.robotSecretKey)
}

// required string systemVersion = 5;
inline bool init::has_systemversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void init::clear_systemversion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.systemversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& init::systemversion() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AIAssistant.init.systemVersion)
  return _internal_systemversion();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void init::set_systemversion(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.systemversion_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:AIAssistant.init.systemVersion)
}
inline std::string* init::mutable_systemversion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_systemversion();
  // @@protoc_insertion_point(field_mutable:AIAssistant.init.systemVersion)
  return _s;
}
inline const std::string& init::_internal_systemversion() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.systemversion_.Get();
}
inline void init::_internal_set_systemversion(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.systemversion_.Set(value, GetArena());
}
inline std::string* init::_internal_mutable_systemversion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.systemversion_.Mutable( GetArena());
}
inline std::string* init::release_systemversion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AIAssistant.init.systemVersion)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.systemversion_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.systemversion_.Set("", GetArena());
  }
  return released;
}
inline void init::set_allocated_systemversion(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.systemversion_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.systemversion_.IsDefault()) {
    _impl_.systemversion_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:AIAssistant.init.systemVersion)
}

// required int32 softWareXPos = 6;
inline bool init::has_softwarexpos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void init::clear_softwarexpos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.softwarexpos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t init::softwarexpos() const {
  // @@protoc_insertion_point(field_get:AIAssistant.init.softWareXPos)
  return _internal_softwarexpos();
}
inline void init::set_softwarexpos(::int32_t value) {
  _internal_set_softwarexpos(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:AIAssistant.init.softWareXPos)
}
inline ::int32_t init::_internal_softwarexpos() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.softwarexpos_;
}
inline void init::_internal_set_softwarexpos(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.softwarexpos_ = value;
}

// required int32 softWareYPos = 7;
inline bool init::has_softwareypos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void init::clear_softwareypos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.softwareypos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t init::softwareypos() const {
  // @@protoc_insertion_point(field_get:AIAssistant.init.softWareYPos)
  return _internal_softwareypos();
}
inline void init::set_softwareypos(::int32_t value) {
  _internal_set_softwareypos(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:AIAssistant.init.softWareYPos)
}
inline ::int32_t init::_internal_softwareypos() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.softwareypos_;
}
inline void init::_internal_set_softwareypos(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.softwareypos_ = value;
}

// required int32 softWareWidth = 8;
inline bool init::has_softwarewidth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void init::clear_softwarewidth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.softwarewidth_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t init::softwarewidth() const {
  // @@protoc_insertion_point(field_get:AIAssistant.init.softWareWidth)
  return _internal_softwarewidth();
}
inline void init::set_softwarewidth(::int32_t value) {
  _internal_set_softwarewidth(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:AIAssistant.init.softWareWidth)
}
inline ::int32_t init::_internal_softwarewidth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.softwarewidth_;
}
inline void init::_internal_set_softwarewidth(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.softwarewidth_ = value;
}

// required int32 softWareHeight = 9;
inline bool init::has_softwareheight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void init::clear_softwareheight() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.softwareheight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t init::softwareheight() const {
  // @@protoc_insertion_point(field_get:AIAssistant.init.softWareHeight)
  return _internal_softwareheight();
}
inline void init::set_softwareheight(::int32_t value) {
  _internal_set_softwareheight(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:AIAssistant.init.softWareHeight)
}
inline ::int32_t init::_internal_softwareheight() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.softwareheight_;
}
inline void init::_internal_set_softwareheight(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.softwareheight_ = value;
}

// -------------------------------------------------------------------

// initResponse

// required bool success = 1;
inline bool initResponse::has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void initResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool initResponse::success() const {
  // @@protoc_insertion_point(field_get:AIAssistant.initResponse.success)
  return _internal_success();
}
inline void initResponse::set_success(bool value) {
  _internal_set_success(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:AIAssistant.initResponse.success)
}
inline bool initResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void initResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// required string responseMsg = 2;
inline bool initResponse::has_responsemsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void initResponse::clear_responsemsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.responsemsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& initResponse::responsemsg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AIAssistant.initResponse.responseMsg)
  return _internal_responsemsg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void initResponse::set_responsemsg(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.responsemsg_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:AIAssistant.initResponse.responseMsg)
}
inline std::string* initResponse::mutable_responsemsg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_responsemsg();
  // @@protoc_insertion_point(field_mutable:AIAssistant.initResponse.responseMsg)
  return _s;
}
inline const std::string& initResponse::_internal_responsemsg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.responsemsg_.Get();
}
inline void initResponse::_internal_set_responsemsg(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.responsemsg_.Set(value, GetArena());
}
inline std::string* initResponse::_internal_mutable_responsemsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.responsemsg_.Mutable( GetArena());
}
inline std::string* initResponse::release_responsemsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AIAssistant.initResponse.responseMsg)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.responsemsg_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.responsemsg_.Set("", GetArena());
  }
  return released;
}
inline void initResponse::set_allocated_responsemsg(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.responsemsg_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.responsemsg_.IsDefault()) {
    _impl_.responsemsg_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:AIAssistant.initResponse.responseMsg)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// userContext

// map<string, string> context = 1;
inline int userContext::_internal_context_size() const {
  return _internal_context().size();
}
inline int userContext::context_size() const {
  return _internal_context_size();
}
inline void userContext::clear_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.context_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& userContext::_internal_context() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.context_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& userContext::context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:AIAssistant.userContext.context)
  return _internal_context();
}
inline ::google::protobuf::Map<std::string, std::string>* userContext::_internal_mutable_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.context_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* userContext::mutable_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:AIAssistant.userContext.context)
  return _internal_mutable_context();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// command

// required string commandMsg = 1;
inline bool command::has_commandmsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void command::clear_commandmsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commandmsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& command::commandmsg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AIAssistant.command.commandMsg)
  return _internal_commandmsg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void command::set_commandmsg(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.commandmsg_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:AIAssistant.command.commandMsg)
}
inline std::string* command::mutable_commandmsg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_commandmsg();
  // @@protoc_insertion_point(field_mutable:AIAssistant.command.commandMsg)
  return _s;
}
inline const std::string& command::_internal_commandmsg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.commandmsg_.Get();
}
inline void command::_internal_set_commandmsg(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.commandmsg_.Set(value, GetArena());
}
inline std::string* command::_internal_mutable_commandmsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.commandmsg_.Mutable( GetArena());
}
inline std::string* command::release_commandmsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AIAssistant.command.commandMsg)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.commandmsg_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.commandmsg_.Set("", GetArena());
  }
  return released;
}
inline void command::set_allocated_commandmsg(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.commandmsg_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.commandmsg_.IsDefault()) {
    _impl_.commandmsg_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:AIAssistant.command.commandMsg)
}

// map<string, string> params = 2;
inline int command::_internal_params_size() const {
  return _internal_params().size();
}
inline int command::params_size() const {
  return _internal_params_size();
}
inline void command::clear_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.params_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& command::_internal_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.params_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& command::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:AIAssistant.command.params)
  return _internal_params();
}
inline ::google::protobuf::Map<std::string, std::string>* command::_internal_mutable_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.params_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* command::mutable_params() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:AIAssistant.command.params)
  return _internal_mutable_params();
}

// -------------------------------------------------------------------

// commandResponse

// required bool success = 1;
inline bool commandResponse::has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void commandResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool commandResponse::success() const {
  // @@protoc_insertion_point(field_get:AIAssistant.commandResponse.success)
  return _internal_success();
}
inline void commandResponse::set_success(bool value) {
  _internal_set_success(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:AIAssistant.commandResponse.success)
}
inline bool commandResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void commandResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// required string responseMsg = 2;
inline bool commandResponse::has_responsemsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void commandResponse::clear_responsemsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.responsemsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& commandResponse::responsemsg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AIAssistant.commandResponse.responseMsg)
  return _internal_responsemsg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void commandResponse::set_responsemsg(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.responsemsg_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:AIAssistant.commandResponse.responseMsg)
}
inline std::string* commandResponse::mutable_responsemsg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_responsemsg();
  // @@protoc_insertion_point(field_mutable:AIAssistant.commandResponse.responseMsg)
  return _s;
}
inline const std::string& commandResponse::_internal_responsemsg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.responsemsg_.Get();
}
inline void commandResponse::_internal_set_responsemsg(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.responsemsg_.Set(value, GetArena());
}
inline std::string* commandResponse::_internal_mutable_responsemsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.responsemsg_.Mutable( GetArena());
}
inline std::string* commandResponse::release_responsemsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AIAssistant.commandResponse.responseMsg)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.responsemsg_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.responsemsg_.Set("", GetArena());
  }
  return released;
}
inline void commandResponse::set_allocated_responsemsg(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.responsemsg_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.responsemsg_.IsDefault()) {
    _impl_.responsemsg_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:AIAssistant.commandResponse.responseMsg)
}

// -------------------------------------------------------------------

// statusRepost

// required int32 status = 1;
inline bool statusRepost::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void statusRepost::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t statusRepost::status() const {
  // @@protoc_insertion_point(field_get:AIAssistant.statusRepost.status)
  return _internal_status();
}
inline void statusRepost::set_status(::int32_t value) {
  _internal_set_status(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:AIAssistant.statusRepost.status)
}
inline ::int32_t statusRepost::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_;
}
inline void statusRepost::_internal_set_status(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// required string responseMsg = 2;
inline bool statusRepost::has_responsemsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void statusRepost::clear_responsemsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.responsemsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& statusRepost::responsemsg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AIAssistant.statusRepost.responseMsg)
  return _internal_responsemsg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void statusRepost::set_responsemsg(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.responsemsg_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:AIAssistant.statusRepost.responseMsg)
}
inline std::string* statusRepost::mutable_responsemsg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_responsemsg();
  // @@protoc_insertion_point(field_mutable:AIAssistant.statusRepost.responseMsg)
  return _s;
}
inline const std::string& statusRepost::_internal_responsemsg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.responsemsg_.Get();
}
inline void statusRepost::_internal_set_responsemsg(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.responsemsg_.Set(value, GetArena());
}
inline std::string* statusRepost::_internal_mutable_responsemsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.responsemsg_.Mutable( GetArena());
}
inline std::string* statusRepost::release_responsemsg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AIAssistant.statusRepost.responseMsg)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.responsemsg_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.responsemsg_.Set("", GetArena());
  }
  return released;
}
inline void statusRepost::set_allocated_responsemsg(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.responsemsg_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.responsemsg_.IsDefault()) {
    _impl_.responsemsg_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:AIAssistant.statusRepost.responseMsg)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace AIAssistant


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // utils_2fAIAssistant_2epipeMsg_2eproto_2epb_2eh
